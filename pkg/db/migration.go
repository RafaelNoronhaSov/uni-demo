package db

import (
	"context"
	"log"
	"math/rand"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/jaswdr/faker"
)

const ddl = `
DROP TABLE IF EXISTS CLASS_SCHEDULE;
DROP TABLE IF EXISTS SUBJECT_PREREQUISITE;
DROP TABLE IF EXISTS PROFESSOR_SUBJECT;
DROP TABLE IF EXISTS CLASS;
DROP TABLE IF EXISTS ROOM;
DROP TABLE IF EXISTS PROFESSOR;
DROP TABLE IF EXISTS SUBJECT;
DROP TABLE IF EXISTS BUILDING;
DROP TABLE IF EXISTS TITLE;
DROP TABLE IF EXISTS DEPARTMENT;

CREATE TABLE DEPARTMENT (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(100) NOT NULL UNIQUE
);
CREATE TABLE TITLE (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(100) NOT NULL UNIQUE
);
COMMENT ON TABLE TITLE IS 'Tabela que armazena os títulos associados aos professores';

CREATE TABLE BUILDING (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(100) NOT NULL UNIQUE
);
COMMENT ON TABLE BUILDING IS 'Tabela que armazena os prédios associados as disciplinas';

CREATE TABLE SUBJECT (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    subject_code VARCHAR(10) NOT NULL UNIQUE,
    name VARCHAR(100) NOT NULL
);
COMMENT ON TABLE SUBJECT IS 'Tabela que armazena as disciplinas';
COMMENT ON COLUMN SUBJECT.subject_code IS 'Código da disciplina (ex: "CS101", "MATH203")';

CREATE TABLE PROFESSOR (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	first_name VARCHAR(50) NOT NULL,
	last_name VARCHAR(50) NOT NULL,
    department_id INT NOT NULL,
    title_id INT NOT NULL,
    FOREIGN KEY (department_id) REFERENCES DEPARTMENT(id),
    FOREIGN KEY (title_id) REFERENCES TITLE(id)
);
COMMENT ON TABLE PROFESSOR IS 'Tabela que armazena os professores';
COMMENT ON COLUMN PROFESSOR.department_id IS 'Departamento do professor';
COMMENT ON COLUMN PROFESSOR.title_id IS 'Título do professor';

CREATE TABLE ROOM (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    building_id INT NOT NULL,
    room_number VARCHAR(10) NOT NULL,
    FOREIGN KEY (building_id) REFERENCES BUILDING(id),
    UNIQUE(building_id, room_number)
);
COMMENT ON TABLE ROOM IS 'Tabela que armazena as salas';
COMMENT ON COLUMN ROOM.building_id IS 'Prédio da sala';

CREATE TABLE PROFESSOR_SUBJECT (
    professor_id INT NOT NULL,
    subject_id INT NOT NULL,
    PRIMARY KEY (professor_id, subject_id),
    FOREIGN KEY (professor_id) REFERENCES PROFESSOR(id),
    FOREIGN KEY (subject_id) REFERENCES SUBJECT(id)
);
COMMENT ON TABLE PROFESSOR_SUBJECT IS 'Tabela que armazena os professores e as disciplinas que eles lecionam';

CREATE TABLE SUBJECT_PREREQUISITE (
    subject_id INT NOT NULL,
    prerequisite_id INT NOT NULL,
    PRIMARY KEY (subject_id, prerequisite_id),
    FOREIGN KEY (subject_id) REFERENCES SUBJECT(id),
    FOREIGN KEY (prerequisite_id) REFERENCES SUBJECT(id),
    CHECK (subject_id != prerequisite_id)
);
COMMENT ON TABLE SUBJECT_PREREQUISITE IS 'Tabela que armazena as disciplinas e suas pre-requisitos';

CREATE TABLE CLASS (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    subject_id INT NOT NULL,
    professor_id INT NOT NULL,
    year INT NOT NULL,
    semester SMALLINT NOT NULL,
    section_code VARCHAR(10) NOT NULL,
    FOREIGN KEY (subject_id) REFERENCES SUBJECT(id),
    FOREIGN KEY (professor_id) REFERENCES PROFESSOR(id),
    UNIQUE(subject_id, year, semester, section_code)
);
COMMENT ON TABLE CLASS IS 'Tabela que armazena as turmas';

CREATE TABLE CLASS_SCHEDULE (
    id INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    class_id INT NOT NULL,
    room_id INT NOT NULL,
    day_of_week SMALLINT NOT NULL,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    FOREIGN KEY (class_id) REFERENCES CLASS(id) ON DELETE CASCADE,
    FOREIGN KEY (room_id) REFERENCES ROOM(id)
);
COMMENT ON TABLE CLASS_SCHEDULE IS 'Tabela que armazena os horários das turmas';
`

func Connect(dbURL string) (*pgxpool.Pool, error) {
	pool, err := pgxpool.New(context.Background(), dbURL)
	if err != nil {
		return nil, err
	}

	if err := pool.Ping(context.Background()); err != nil {
		return nil, err
	}

	return pool, nil
}

func Migrate(pool *pgxpool.Pool) error {
	_, err := pool.Exec(context.Background(), ddl)
	return err
}

func Seed(pool *pgxpool.Pool) error {
	var count int
	err := pool.QueryRow(context.Background(), "SELECT COUNT(*) FROM PROFESSOR").Scan(&count)
	if err != nil {
		return err
	}
	if count > 0 {
		log.Println("Banco jÁ populado...")
		return nil
	}

	ctx := context.Background()
	f := faker.New()

	departments := []string{"Ciência da Computação", "Engenharia Elétrica", "Matemática", "Física"}
	titles := []string{"Professor Assistente", "Professor Adjunto", "Professor Titular"}
	buildings := []string{"Bloco A", "Bloco B - Engenharia", "Bloco C - Exatas"}
	subjects := []struct{ Code, Name string }{
		{"CS101", "Introdução à Programação"}, {"CS202", "Estruturas de Dados"},
		{"EE301", "Circuitos Elétricos"}, {"MA101", "Cálculo I"}, {"PH101", "Física Básica"},
	}

	departmentIDs, _ := insertAndGetIDs(pool, "INSERT INTO DEPARTMENT(name) VALUES($1) RETURNING id", departments)
	titleIDs, _ := insertAndGetIDs(pool, "INSERT INTO TITLE(name) VALUES($1) RETURNING id", titles)
	buildingIDs, _ := insertAndGetIDs(pool, "INSERT INTO BUILDING(name) VALUES($1) RETURNING id", buildings)

	subjectIDs := make([]int, len(subjects))
	for i, s := range subjects {
		pool.QueryRow(ctx, "INSERT INTO SUBJECT(subject_code, name) VALUES($1, $2) RETURNING id", s.Code, s.Name).Scan(&subjectIDs[i])
	}

	var professorIDs []int
	for i := 0; i < 10; i++ {
		var id int
		pool.QueryRow(ctx,
			"INSERT INTO PROFESSOR(first_name, last_name, department_id, title_id) VALUES($1, $2, $3, $4) RETURNING id",
			f.Person().FirstName(), f.Person().LastName(), departmentIDs[rand.Intn(len(departmentIDs))], titleIDs[rand.Intn(len(titleIDs))],
		).Scan(&id)
		professorIDs = append(professorIDs, id)
	}

	var roomIDs []int
	for i := 0; i < 15; i++ {
		var id int
		pool.QueryRow(ctx,
			"INSERT INTO ROOM(building_id, room_number) VALUES($1, $2) RETURNING id",
			buildingIDs[rand.Intn(len(buildingIDs))], f.Bothify("?###"),
		).Scan(&id)
		roomIDs = append(roomIDs, id)
	}

	for i := 0; i < 8; i++ {
		var classID int
		err := pool.QueryRow(ctx,
			"INSERT INTO CLASS(subject_id, professor_id, year, semester, section_code) VALUES ($1, $2, $3, $4, $5) RETURNING id",
			subjectIDs[rand.Intn(len(subjectIDs))],
			professorIDs[rand.Intn(len(professorIDs))],
			2025,
			1,
			f.Bothify("T?#"),
		).Scan(&classID)
		if err != nil {
			log.Printf("Falha ao inserir registro na tabela class: %v", err)
			continue
		}

		for j := 0; j < 2; j++ {
			startTime := time.Date(0, 0, 0, 8+rand.Intn(8), 0, 0, 0, time.UTC)
			endTime := startTime.Add(time.Hour * 2)
			_, err := pool.Exec(ctx,
				"INSERT INTO CLASS_SCHEDULE(class_id, room_id, day_of_week, start_time, end_time) VALUES ($1, $2, $3, $4, $5)",
				classID, roomIDs[rand.Intn(len(roomIDs))], rand.Intn(5)+1, startTime, endTime,
			)
			if err != nil {
				log.Printf("Falha ao inserir registro na tabela class_schedule: %v", err)
			}
		}
	}
	return nil
}

func insertAndGetIDs(pool *pgxpool.Pool, query string, items []string) ([]int, error) {
	var ids []int
	for _, item := range items {
		var id int
		err := pool.QueryRow(context.Background(), query, item).Scan(&id)
		if err != nil {
			return nil, err
		}
		ids = append(ids, id)
	}
	return ids, nil
}
